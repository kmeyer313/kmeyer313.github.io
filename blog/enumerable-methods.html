<!DOCTYPE html>
<html lang="en">

<head>
  <title>Enumerable Methods</title>
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog.css">
</head>

<main>
  <h1 class="quote"> <p>"The journey of a thousand miles begins with a single step." ~ Lao Tzu</p></h1>
  <h3><a href="../blog/index.html">Return to main blog</a></h3>
  <h2>Enumerable Methods</h2>
  <h4>December 14, 2015</h4>

  <section>
    <h3>Christmas Game Time!</h3>
    <p>Alright, Newbs! Time to stretch out this brain again… Hang in there! Christmas break is almost here!</p>
    <p>My dad coincidentally used the word “innumerable” when describing one of his “favorite” politicians when we were talking about politics this week. (I am not here to start a political discourse, so I’ll stop right there with that.) I turned to good old Google to parse out the difference between innumerable and enumerable. What I found makes sense for each word in their separate contexts. Innumerable means so many times it cannot be counted. So from my dad’s perspective, the politician has done something an innumerable amount of times (okay, maybe my dad was exaggerating).</p>
    <p>The idea of innumerable can be a little terrifying in the programming world because if our program runs innumerably, it may crash!? Enumerable is much less intimidating as it describes something that is countable. Enumerate means to mention (a number of things) one by one. In Ruby, enumerable is Ruby’s way of saying that we can get elements out of a collection, one by one, and do something with them. This is incredibly useful for Rubyists!</p>
    <p>To be honest, things get a little confusing when we dig into Ruby and start talking about the difference between <code>Enumerable</code> and <code>Enumerator</code>. Here is a minimal explanation that I gleaned from <a href="https://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/44-collections/lessons/96-enumerators-and-enumerables">Ruby Monk</a>. <code>Enumerable</code> is a <code>module</code> (which a way of grouping together methods, classes, and constants) used as a <code>mixin</code> that could be used in the class such as <code>Array</code>. It provides a number of enumerators, like <code>.map</code>, <code>.select</code>, <code>.inject</code>… etc. <code>Enumerator</code> is a class of <code>Object</code>. “Enumerators are objects that encapsulate knowledge of how to iterate through a particular collection” (<em>The Well-Grounded Rubyist</em>, 287). Getting dizzy yet? Our dear friend David A. Black, author of <em>The Well-Grounded Rubyist</em>, mentions that the <code>Enumerable</code> module and the <code>Enumerator</code> class are closely related, so for now we’ll just say, "Okay!" and keep going.</p>
    <p>Any class that uses <code>Enumerable</code> (<code>Array</code>, <code>Hash</code>) or any class you create that for which you want to include the behaviors of the <code>Enumerable</code>, must have their own definition of <code>.each</code>. <code>.each</code> is a method that is simple enough to learn when first exposed to it through iterators and code blocks. We can call <code>.each</code> on an array, followed by a code block telling it what to do with each element of the array. For example:</p>

    <code>array = [1,2,3,4,5]</code>
    <code>array.each { |e| puts “The block just got handed #{e}.” }</code>

    <p>will provide us an output of:<p/>

    <code><p>The block just got handed 1.</p>
    <p>The block just got handed 2.</p>
    <p>The block just got handed 3.</p>
    <p>The block just got handed 4.</p>
    <p>The block just got handed 5.</p>
    <p>=> [1, 2, 3, 4, 5]</p></code>

    <p>The final line is what each returns, the original array, unchanged. Here is another example of <code>.each</code> that I would like you to pay attention to as I will refer to it in the following example.</p>

    <code><p>array = [1, 2, 3]</p>
    <p>array.each {|x| x*10}</p>
    <p>p array</p>
    <p>=> [1, 2, 3]</p></code>

    <p>Again, the return of the array is unchanged. This was pretty confusing to me as I expected the code block to change the value of each item in the array, but I believe that the code block will only retain its output for the use in a particular method definition. As soon as it uses it, it tosses it and reverts back to the original.</p>

    <p>This isn’t always the case with <code>.each</code> as each class has their own definition of what it does. For example, for a hash, using each can change its original value (remember, in the array, it does not). If we have a hash:</p>

    <code><p>hash = { 1=>1,  2=>2,  3=>3 }</p></code>

    <p>and we call <code>.each</code> on that hash,</p>

    <code><p>hash.each { |k,v| hash[k] = v*10}</p></code>

    <p>the return will be <code>{1=>10, 2=>20, 3=>30}</code>.</p>

    <p>What!? Contrary to the array hash, the original hash has been changed! Tricky. I will not go much deeper into this aspect as that’s about as far as I’ve been able to grasp at the moment. However, the point is, every class has its own, although sometimes very similar, definition of <code>.each</code>. So be mindful of the method you are calling when you switch between classes!</p>

    <p><em>(Shoutout to my Accountability Group who helped clear up some of my misunderstandings about <code>.each</code>. These last few paragraphs above are are based on their examples and are somewhat of a synthesis of what I learned from them. They rock!)</em></p>

    <p>A basic understanding of <code>.each</code> will help us understand how <code>Enumerable</code> methods work. Now I want to have some fun and zoom into an <code>Enumberable</code> method that I found interesting and learned about more in-depth this week: <code>.each_slice</code>.</p>

    <code><p>.each_slice</p></code>
    <p>I attempted to use <code>.each_slice</code> in a challenge that required us to define a method that would create groups out of a list of names. It works to a certain extent, but you need to get a little more savvy to meet all the requirements of the challenge. Here is what it <em>can</em> do.</p>

    <p>The scenario: it’s Christmas Day and the cousins are getting ready to play Scattergories. They want to break up into teams, so Katie decides she can whip up a <code>Ruby</code> program really quick to sort the cousins into groups. Here is her program.</p>

    <code><p>cousins = ["Amanda", "Kelsie", "Emylee", "Patrick", "Katie", "Billy", "Maggie", "Alison", "Joseph"]</p>
    <p>cousins.each_slice(3) { |slice| p slice }</p>
    <p>p cousins</p></code>

    <p>will print this output to the console:</p>

    <code><p>["Amanda", "Kelsie", "Emylee"]</p>
    <p>["Patrick", "Katie", "Billy"]</p>
    <p>["Maggie", "Alison", "Joseph"]</p>
    <p>=> ["Amanda", "Kelsie", "Emylee", "Patrick", "Katie", "Billy", "Maggie", "Alison", "Joseph"]</p></code>

    <p>Sweet! It nicely grouped the cousins into three groups of three. Perfect for Scattergories! Calling <code>.each_slice(n)</code> with an argument n tells <code>Ruby</code> how many people she wants in each group. We can see that the value that is returned (on the last line) is the same as the original array. This tells us that this method is <em>non-destructive</em>, it does not change the original array.</p>

    <p>Hmm, but back to the game. The cousins aren’t happy with the teams. The first two groups are made up of siblings (<code>.each_slice</code> just grabs the items in the order that you enter them, and Katie entered them by thinking through each family at a time). It probably wouldn’t be fair to have siblings on the same team, the members of the third group may feel they are at a disadvantage (although in reality, they would LOVE being on a team with each other).</p>

    <p>Katie has an idea, she’ll apply another method she learned from the week to mix things up a little bit. She revises the program:</p>




  </section>
</main>

</html>